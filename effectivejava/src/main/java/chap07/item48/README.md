# item48. 스트림 병렬화는 주의해서 적용하라
동시성 프로그래밍을 할 때는 `안전성(safety)`와 `응답 가능(liveness)` 상태를 유지하도록 해야한다.

## 병렬 수행 효율
``` java
// 스트림을 사용해 처음 20개의 메르센 소수를 생성하는 프로그램
public static void main(String[] args) {
    primes().map(prime -> TWO.pow(prime.intValue()).subtract(ONE))
            .filter(mersenne -> mersenne.isProbablePrime(50))
            .limit(20)
            .forEach(System.out::println);
}

static Stream<BigInteger> primes() {
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```
위 코드에서 속도를 높인다고 스트림 파이프라인의 parallel()을 호출하면 프로그램은 아무것도 출력하지 못하면서 CPU는 90%나 잡아 먹는 상태가 무한히 계속된다.
* 환경이 좋아도 **데이터 소스가 Stream.iterate거나 중간 연산으로 limit을 쓰면 파이프라인 병렬화로 성능 개선을 기대할 수 없다.**
* 즉, 스트림 파이프라인을 마구잡이로 병렬화 하면 안된다는 뜻이다.

## 병렬화 효과가 좋은 스트림
**스트림의  소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.**
* 위 자료구조들은 모두 데이터를 원하는 크기로 나눌 수 있어 일을 다수의 스레드에 분배하기 좋다는 특징이 있다.
* 나누는 작업은 Spliterator가 담당하며, Spliterator 객체는 Stream이나 Iterable의 spliterator 메서드로 얻어올 수 있다.\
* 또한 원소들을 순차적으로 실행할 때의 **참조 지역성**이 뛰어나다. 

### 참조 지역성
* 이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있다는 뜻
* 참조들이 가리키는 실제 객체가 메모리에서 서로 떨어져 있을 수 있는 경우 참조 지역성이 나빠짐
* 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 대부분의 시간을 낭비함
* 참조 지역성은 다량의 데이터를 벌크 연산을 병렬화하는데 아주 중요한 요소로 작용됨
* 참조 지역성이 뛰어난 자료구조는 기본 타입의 배열임

## 스트림 파이프라인의 종단 연산
스트림 파이프라인의 종단 연산의 동작 방식 또한 병렬 수행효율에 영향을 줌
* 종단 연산에서 수행하는 작업량이 파이프라인 전체 작업에서 상당 비중을 차지하면서 순차적인 연산이라면 파이프라인 병렬 수행의 효과는 제한될 수밖에 업다.
* 종단 연산 중 병렬화에 가장 적합한 것은 축소(reduction)다. 축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업이다. 
  * Stream의 reduce 메서드 중 하나, 혹은 min, max, count, sum 같이 완성된 형태로 제공되는 메서드 중 하나를 선택해 수행한다.
* anyMatch, allMatch, noneMatch처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합하다. 
* 가변 축소(mutable reduction)를 수행하는 Stream의 collect 메서드는 컬렉션들을 합치는 부담이 크기 때문에 병렬화에 적합하지 않다. 
* 직접 구현한 Stream, Iterable, Collection이 병렬화의 이점을 제대로 누리게 하고 싶다면 spliterator 메서드를 반드시 재정의하고 성능을 테스트 하도록 해야 한다.

## 성능 저하 
스트림을 잘못 병렬화하면 응답 불가 상태에 빠지거나 성능이 나빠질 수 있고, 결과 자체가 잘못 되거나 예상치 못한 동작이 발생할 수 있다.

### 안전 실패
결과가 잘못되거나 오동작하는 것은 안전 실패(safety failure)라고 한다.
* 안전 실패는 병렬화한 파이프라인이 사용하는 mappers, filters, 혹은 프로그래머가 제공한 다른 함수 객체가 명세대로 동작하지 않을 때 벌어질 수 있다. 
* Stream 명세는 이때 사용되는 함수 객체에 관해 엄격한 규약을 정의해놨다.  

> Stream의 reduce 연산에 건네지는 accumulator(누적기)와 combiner(결합기) 함수는 반드시 결합법칙을 만족(associative)하고, 간섭받지 않고(non-interfering), 상태를 갖지 않아야(stateless) 한다.

## 최적화
* 스트림 병렬화는 오직 성능 최적화의 수단일 뿐이다. 다른 최적화와 마찬가지로 변경 전후로 반드시 성능을 테스트하여 병렬화를 사용할 가치가 있는지 확인해야 한다.
* 보통은 병렬 스트림 파이프라인도 공통의 포크 조인 풀에서 수행되므로(같은 스레드 풀을 사용하므로), 잘못된 파이프라인 하나가 시스템의 다른 부분의 성능에까지 악영향을 줄 수 있다.
* 스트림 병렬화가 효과를 보는 경우는 많지 않으나, 조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 얻을 수 있다.